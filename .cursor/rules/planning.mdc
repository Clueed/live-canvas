---
description: 
globs: 
alwaysApply: false
---
# Iterative Task Planning Guideline

## Introduction / Problem

When tackling complex coding tasks, especially with AI assistance, a well-structured and actionable plan is crucial. This guideline outlines an iterative process to create such plans, ensuring they are both comprehensive and tailored to the specific codebase.

## The Iterative Planning Process

Follow these phases to develop an effective task plan:

### 1. Phase 1: General Outline & Documentation Review

*   **Understand the Goal:** Clearly define the objective of the plan based on the user's request.
*   **Initial Draft:** Create a high-level outline of steps.
*   **Consult Knowledge Sources:**
    *   Review relevant official documentation for tools or libraries involved.
    *   Incorporate general best practices.
    *   Utilize any provided documentation or context (e.g., attached files, web search results).
*   **Output:** A general plan that outlines the approach, possibly with placeholders for codebase-specific details.

### 2. Phase 2: Codebase-Specific Customization & Deep Dive

*   **Thorough Codebase Analysis (Crucial):**
    *   Use available tools (`codebase_search`, `list_dir`, `read_file`, `grep_search`) to explore the project.
    *   Identify existing conventions, tools (e.g., package managers, linters, build systems, UI frameworks, specific database technologies, or server infrastructure), relevant file paths, and configurations.
    *   Understand how the new task fits into the existing architecture and patterns.
*   **Tailor the Plan:**
    *   Replace general commands/steps with codebase-specific equivalents (e.g., use the project's designated package manager, update paths to match the project's directory structure, adapt to the project's chosen API style or database query language).
    *   Update file paths, variable names, and code examples to match project conventions.
    *   Consider how existing project tooling (linters, formatters, CI) will interact with the planned changes.
*   **Output:** A detailed plan customized for the target codebase.

### 3. Phase 3: Refinement, Structuring & Final Review

*   **Structure for Execution:**
    *   Organize the plan into a few (typically 1-5) key, high-level steps or phases.
    *   Each key step should be actionable and, where possible, independently executable and verifiable.
*   **Clarity and Conciseness:**
    *   Ensure each step is clearly described.
    *   Remove redundant information, focusing on actionable instructions.
    *   The overall plan should be easy to follow.
*   **Final Double-Check:**
    *   Verify all commands, file paths, and code snippets for accuracy within the context of the target project.
    *   Confirm the plan directly addresses the user's original request and incorporates all constraints.
*   **Output:** A final, actionable checklist or plan, typically written to `tmp/plan.md`.

## Key Characteristics of the Resulting Plan

The final plan created by this process should exhibit:

*   **Clear, Actionable Steps:** Each item should be a concrete action.
*   **Defined Key Stages:** Broken down into 1-5 major, ideally independent, executable phases.
*   **Codebase Specificity:** All instructions and examples are tailored to the project's actual environment and conventions discovered during Phase 2.
*   **Conciseness:** Provides necessary detail without being verbose.
*   **Standard Location:** Stored in `tmp/plan.md` for easy access and review.

## Example Scenario: Improve Application Performance in a Critical User Flow

Task: Identify and remediate performance bottlenecks in a specified critical user flow of an application.

The resulting plan would be written to `tmp/plan.md` and would follow this iterative development:

1.  **Phase 1: General Outline & Documentation Review:**
    *   **Goal Clarification:** Confirm the specific user flow (e.g., "Order Submission Process," "Dashboard Data Loading").
    *   **Initial High-Level Steps:**
        1.  Profile the identified user flow to establish baseline metrics and locate bottlenecks.
        2.  Research optimization techniques relevant to the general technology stack (e.g., web app, database interactions, client-side rendering).
        3.  Formulate potential remediation strategies based on common performance issues.
    *   **Knowledge Sources:** Review documentation for general-purpose profiling tools, articles on performance optimization for web applications, common database optimization patterns, etc.

2.  **Phase 2: Codebase-Specific Customization & Deep Dive:**
    *   **Tools:** Discover the project utilizes `SpecificProfilerX` for backend profiling and browser developer tools for frontend analysis. Note the backend is `Python/Django` with `PostgreSQL` and the frontend uses `Angular`.
    *   **Code Analysis:**
        *   Trace the critical user flow through the codebase: identify specific Django views, models, database queries (e.g., `Product.objects.filter(...)`), Angular services, and components involved.
        *   Examine existing caching layers (e.g., `Redis`), database indexes, and any known inefficient code paths or large data transfers related to this flow.
    *   **Contextualize Strategies:** Based on findings:
        *   If database queries are slow: Plan to analyze query execution plans for specific `PostgreSQL` queries and add/modify indexes.
        *   If Python code is a bottleneck: Plan to refactor specific Django view logic or utility functions for efficiency.
        *   If Angular frontend is slow: Plan to investigate change detection strategies, optimize component rendering, or reduce bundle sizes for specific modules.

3.  **Phase 3: Refinement, Structuring & Final Review (Content for `tmp/plan.md`):**
    *   **Key Actionable Steps (example derived from hypothetical Phase 2 findings):**
        1.  **Profile & Baseline:** Using `SpecificProfilerX` and browser dev tools, profile the "Order Submission Process," focusing on the `submit_order` Django view and the `OrderReview` Angular component. Document current execution times for key operations.
        2.  **Database Optimization:** Analyze and optimize the `PostgreSQL` query generated by `Order.create_order_items()`. Add a composite index to the `order_items` table on `(order_id, product_id)`.
        3.  **Backend Logic Refactor:** Refactor the `calculate_order_discounts` function within the `submit_order` view to reduce redundant calculations.
        4.  **Frontend Rendering:** Apply `OnPush` change detection strategy to the `OrderSummary` Angular component and its children. Ensure large static assets for this flow are efficiently bundled and lazy-loaded if possible.
        5.  **Verification & Measurement:** Re-profile the "Order Submission Process" after all changes. Compare against baseline metrics and document the achieved performance improvement.
    *   **Final Review:** Confirm that the tools (`SpecificProfilerX`), language constructs (Django ORM, Angular specific_APIs), and database details (`PostgreSQL` indexing) are correctly referenced and that the steps are logical and address the identified bottlenecks.

## Why This Process Is Effective

*   **Relevance:** Ensures the plan is directly applicable to the user's environment.
*   **Accuracy:** Reduces errors by grounding the plan in the specifics of the codebase.
*   **Efficiency:** Provides a clear roadmap, facilitating smoother task execution with AI.
*   **Standardization:** Writing plans to `tmp/plan.md` provides a consistent location for review and reference.
